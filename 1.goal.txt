1. Цель курса
-------------

Современная расшифровка аббревиатуры NoSQL - Not Only SQL. 
Что значит Not Only? Как определяется это множество? 

В этом курсе этот мир определяется как мир систем управления
базами данных. Все системы непосредственно накапливающие информацию и
предоставляющие доступ к ней так или иначе подпадают под это определение.

Задача курса - дать специалисту разрабатывающему более масштабные
системы пространство классификации, топологию, для того чтобы
ориентироваться в мире СУБД решений.

Так почему же NoSQL? NoSQL сегодня наиболее разнообразный, и
наиболее сложный в классификации, и наиболее динамично развивающийся
мир СУБД, и поэтому представляет наибольшую когнитивную проблему. 

Одной из уникальных составляющих курса я бы назвал введённое пространство
классификации современных СУБД систем. Пространство 
состоит из трёх размерностей:

- модель данных - от структурированных данных к ненормализованным
  данным, таким как JSON
- модель консистентности данных - от ACID к BASE
- фундаментальные принципы и алгоритмы хранения данных,
  положенные в основы системы - от простого логирования к
  column-store и graph store.

Для понимания многообразий NoSQL решений необходимо осознавать, что
пространство решений не непрерывно - помимо ограничений,
сформированных проблемами и задачами, решаемыми СУБД, выбор точки
в одной из размерностей "мотивирует" разработчика СУБД выбрать
наиболее связанные с ней решения и принципы из других размерностей. 

Действительно, при анализе существующих решений мы увидим,
например, что документно-ориентированные СУБД часто выбирают 
eventual consistency и атомарность хранения, без поддержки
сложных транзакций. Графовые и реляционные СУБД, предполагающие
высокую степень декомпозиции данных, наоборот, часто предоставляют
ACID транзакции.

Похожим образом in-memory СУБД ориентированы на более простые
модели данных, т.к. память до сих пор существенно дороже чем 
диск.

2. Причины возникновения NoSQL движения.
----------------------------------------

Для понимания природы NoSQL наиболее важными представляются
следующие причины (debatable)

- недостатки реляционных систем
- решение задач обработки данных на которые реляционные, объектные
и XML системы не были рассчитаны
- реструктуризация IT рынка

Остановимся на этих причинах подробнее. 

2a. Недостатки реляционных систем

Недостатки реляционных систем - бурная тема для обсуждений начиная с начала
1990х годов  - достаточно вспомнить Object-Oriented Database System
manifesto by Atkinson et al, и Third Manifesto by Date/Darwin. Это и
несоответствие реляционной модели модели объектно-ориентированной (так
называемый object-relational impedance mismatch), и недостаточная
"реляционность" языка SQL, и "ориентированность" стандарта SQL во 
множестве аспектов (уровни изоляции транзакций, APIs, Unicode support, 
object extentions, и пр. пр.) на интересы одного вендора.

Но, как показывает судьба объектных систем, эти недостатки оказались явно
недостаточны для того чтобы свергнуть SQL и реляционные системы с позиции
лидерства в индустрии СУБД. В самом деле, многие популярные объектные
системыиз 90х, такие как InterSystems Cache позиционируют себя сейчас как
NoSQL решения, и имеют лишь нишевые применения, такие как ИТМ
(информационные технологии в медицине).

Более критичными аспектами реляционных систем (но не всегда реляционной
модели!) принято считать следующее:

- rigidity of schema design and change.  Реляционные системы зародились во
времена доминирования waterfall model в инженерии ПО, т.е. рассчитывались на
тщательную проработку каждого аспекта функционирования системмы. Одним из
таких аспектов был изменение схемы данных. Область применения реляционных
систем, таких как banking, часто предполагала возможность частичного
downtime, то есть задача online schema change не стояла остро до 2000х гг. и
начала применения реляционных баз в веб проектах.

- архитектура вертикального масштабирования. Большая часть реляционных
систем, опять же, были рассчитаны на клиент-серверное применение с
вертикальным масштабированием серверных мощностей. MySQL, как первая
система поддерживающая репликацию и горизонтальноое масштабирование 
получила широкое распространение в мире Web именно благодаря этому.

Радикальные изменения в архитектуре аппаратного обеспечения обогнали
продукты СУБД на два поколения: процессы сменились тредами, а модель
тредов и критических секций, в свою очередь, lock-free структурами данных.
"Типичный процессор для СУБД", в свою очередь, сменился на кластер
однотипных машин с малым числом процессоров, а кластер машин с малым числом процессоров - кластером машин с 24-100 процессорами на каждой.
Таким образом, производительность РСУБД даже на single-server
системе стала неадекватной (performance of a single server problem).

Фактически, в силу радикального изменения как оборудования так и 
*начальных* требований к возможностям СУБД в 2000х открылось "окно"
в результате которого на рынок получило возможность выйти множество
систем.

- неготовность к горизонтальному масштабированию (scale-out data) 
- как с точки зрения традиционной теории нормализации (и как следствии
необходимости во вторичных ключах, которые не шардятся), так и вследствие
неготовности к задачам нового рынка, так и вследствие наследия
клиент-серверной архитектуры, с централизованной обработкой запросов на
сервере и простым клиентом. (Для эффективной реализации шардинга и
распределённых запросов необходим "умный" клиент).  Подробнее этот момент
станет понятен после обсуждения моделей данных NoSQL СУБД

Однако не стоит переоценивать проблему горизонтального масштабирования: 
масштабироваться дожно веб приложение, что не всегда означает
необходимость масштабирования на уровне СУБД

2b. Новые задачи возникшие перед СУБД

Доступность оборудования для хранения дала возможность
в коммерческих целях хранить и обрабатывать совершенно
иные объёмы данных, объёмы недоступные ни одной вертикально
масштабируемой системе. Для сравнения, 

Эти задачи можно в целом обозначить как задачи Big Data,
характеризуемые 3мя V- velocity, variety, volume

Здесь роль также сыграла закрытость большинства коммерческих продуктов. 
Бизнес модель большинства интернет-компаний не позволяет иметь
лицензионные отчисления per cpu/per code/per node - часто для простейшего
с минимальной прибыльностью необходимо использовать десятки и сотни узлов.
таким образом, выбор мог быть осуществлён только среди открытых систем
(MySQL, PostgreSQL), которые мгновенно были "захлёстнуты" волной
интереса, ни одна из которых не была приспособлена к
горизонтальному масштабированию.

Также следует упомянуть что SQL системы, созданные в первую очередь
для обработки финансовых транзакций и поддержки accounting
не были рассчитаны на Amazon Shopping Basket сценарий, когда 
Availability goes before Consistency или необходима отказоустойчивая
работа в условиях геораспределённого data center.

Таким образом возникли движения 2b.1. Big Data, Eventual consistency
(Amazon Shopping Basket), нишевые применения (Graph databases).

Efficiency : The system needs to function on a commodity hardware
infrastructure. In Am azon’s platform, services have stringent latency requi
rements which are in general measured at the 99.9 th percentile of the
distribution. Given that state access plays a crucial role in service
operation the storage system must be capable of meeting such stringent SLAs
(see

2c. Рынок применения СУБД значительно расшириллся. Фактически, в 2013 
СПО обязано быть СПО - системное программное обеспечение обязано быть 
свободным, чтобы снискать минимальную популярность и получить рынок.
Парадигма отношения к СУБД как к сложному системному продукту разрабатываемому по принципам "one size fits all", сменилась на парадигму 
polyglot persistence - когда для решения каждой задачи хранения данных
выбирается наиболее подходящий под эту задачу инструмент.

Надо понимать что при наличии NoSQL движения, многие крупные компании
по-прежнему успешно используют MySQL и др. реляционные СУБД как
своё основное хранилище (Facebook, Badoo, много -Google, even Amazon
for many parts of its infrastructure)

При анализе причин возникновения NoSQL не следует забывать
также исторические факторы.

3. Обзор текущего многообразия мира СУБД
----------------------------------------

Слайд 1.

О чём мы не будем говорить сегодня.

Пространство решений для хранения управления данными огромно. 
Я намеренно исключил из этого доклада big data явление и решения
для big data - это тоже NoSQL, но это новая ниша для которой
не существовало ни у кого до этого решений. Тесное взаимодействие
Сloudera с Oracle Corp и Intel Corp говорит о том, что это уже
сформировавшаяся ниша, которую настала пора осваивать всем.

Слайд 2. 

Для анализа оставшевсегося пространства, я предлагаю 
концептуальную систему координаат состоящую из 3х размерностей.

Я утверждаю что каждоё существующее NoSQL решение описывается
точкой в этой системе координат, и рекомендую всем, кто пытается
разобраться в многообразоном рынке MySQL взять её на вооружение.

Давайте кратко пройдёмся по каждой размерности:

1. Хранение данных - это компромисс между скоростью сохранения и скоростью
   доступа, скоростью запросов и типами запросов.

Пора останавливать меня и задавать вопросы!


2. Консистентность данных - отражает многообразие use cases
которые уже вышли за пределы OLTP систем

3. Модели данных - отражает как удобство использования так и взаимодействие
со всеми остальными пространствами, т.к. модель данных диктует целый
ряд ограничений как на алгоритмы хранения так и на алгоритмы поддержки
консистентности данных.

Слайд 3.
---------

Прежде чем мы начнём разбираться в NoSQL системах, давйте посмотрим
поподробнее на проблемы реляционных систем. Почему они не смогли занять новые
ниши, что им успешно удавалось делать в течение 40 лет?

Совпал *по времени* целый ряд факторов, основные я постараюсь сейчас
перечислить:

- в реляционной модели вы проектируте приложение в водопадном стиле
- мир больше не такой.

- вы сообщаете СУБД всё о своём приложении - вы больше не знаете всего

- они не готовы к тому что ыэто изменится - это на самом деел просто
 проблема реализации.

- нормализация плохо распределяется на кластер

- консистентность - реляционные системы поддерживают только ACID, 
а как мы будем говорить, периодически вам не нужен распределённый
ACID, он чрезвычайно дорог 

- расширился рынок СУБД, появилась возможность создавать специализированные
  решения

- архитектура клиент-сервер не подходит для современного железа, системы
созданные для вертикального масштабирования плохо масштабируются
горизонтально.

Надо сказать что NoSQL системы отвергли не только недостатки SQL,
но и их преимущества и поэтому вы иногда вынуждены жрать кактус.

Слайд 4.
---------

Давайте вернёмся теперь к нашей системе координат,
рассмотрим модели данных NoSQL и посмотрим какие нерешённые проблемы
они решают.

У нас есть: (см. слайд).


Слайд 5.

Давайте попробуем разобраться во всём этом чуть подробнее, рассмотрим
модели данных.


Слайд 14.
--------

Вот такое многообразие юзе кейсов с точки зрения моделей данных.
Так что же с моделью консистентности.

Из дальнейшего рассмотрения давайте исключим графовые базы:
- нет распределённых до сих пор
- распределённые - отдельная ниша и рынок, только крупные игроки 
- похожи на реляционки


Агрегат легко кластеризовать, по тому или иному принципу размазать
по кластеру. 

Агрегат часто обновляется целиком. 

Но почему оказываются невостребованными транзакции для таких баз?

Давайте рассмотрим классический сценарий работы через веб.

Таким образом, мы имеем два взгляда на консистентность: 
логическая консистентность и физическая консистентность, и часто нет
необходимости в требованиях к физической консистентности если
не требуется серьёзная физическая.

Решение часто принимается на бизнес уровне, давайте рассмотрим
три специфических кейса.

(кейсы).

0. What we're not going to talk about: big data products, Hadoop, Elliptics

1. Three dimensions.

Для того

3. Three problems of relational databases.


2. Dimension Data Model - how it all started, history of NoSQL

How is XML data model differnet from JSON/Document store?

You have a schema.

Implicit schema.

Nothing is perfect - rearranging the data is straightforward.

Aggregate orientation is an advantage if you want a quick 
put/get of entire aggregate. It's a disadvantage if there is
more than one way in which you slice & dice your data.

Classical normalization problem. Map/reduce jobs.

4. Dimension 2 - data persistency 

5. Dimension 4 - data consistency

6. Future of SQL - NewSQL 

7. Future of NoSQL - feature convergence, cloud computing

8. Future of Hadoop, Cassandra, Hypertable

