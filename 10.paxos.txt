Эта глава является переводом и объяснением white paper Leslie Lamport'а
"Paxos made simple"

Как мы знаем из предыдущих глав, консистентность в распределённой
системе поддерживается одним из протоколов распределённых транзакций.

Один из таких протоколов - протокол дфухвазного подтверждения транзакций,
существовавший  и активно использовавшийся в  в транзакционных системах,
вторым алгоритмом распределённых транзакций часто называют Paxos.

Надо понимать, что Paxos это всё же скорее протокол принятия
решений, чем подтверждения транзакций - т.к. его требования к участникам
иные, чем требования к участникам в протоколе двухвазных блокировок.

Гарантии, в результате "успеха" алгоритма paxos также иные:

в случае двухфазного коммита, результатом является подтверждение 
ACID транзакции на каждом из узлов. В случае Paxos результатом 
является решение, принятое в кластере, и валидное лишь для кластера
в целом - если случится так что в ядерной войне в итоге выживет
лишь один из узлов, которыый "выпал" из кластера в процессе
принятия решения, то решение на этом узле окажется непринятым -
существенно более слабый результат, не так ли?

Как мы увидим с другими алгоритмами даже эти гарантии могут быть слишком
сильными в распределённых системах. 


Таким образом паксос, например, используется как способ выбора координатора
в протоколе двухфазного коммита.

Итак, что же такое Паксос.

Является ли Паксос уникальным для NoSQL? Конечно же нет. Paxos *emerged* 
в мире CSP Hoare's, то есть в мире формальных моделей для
взаимодействующих процессов, и использовался в первую очередь для
коммуникационных систем, а не систем СУБД.


Паксос, описанный на простом языке, а не в нотации CSP,
очень прост.

Введение
--------

Паксос долгое время считался сложным для понимания, возможно из-за
того, что оригинальное изложения алгоритма было для многих "на Греческом". 
На самом деле это один из самых простых и очевидных распределённых алгоритмов.
В сердце Паксос алгоритм консенсуса, также известный как алгоритм "Синода",
т.е. собрания. В этой статье показано, что этот алгоритм следует
практически неизбежно из задач, которые перед ним ставятся. 
Последняя секция статьи объясняет Паксос в принципах
конечных автоматов, отобразив роли данного распределённого
алгоритма на состояния конечного автомата - подход,
широко известный, т.к. описан в одной из наиболее цитируемых 
статей по теории распределённых систем (CSP Hoare)

2. Алгоритм консенсуса
----------------------

2.1. Постановка задачи. 

Представим себе набор процессов, которые делают друг другу 
предложения. Каждое из предложений представлено неким значением. 
Задача алгоритма консенсуса - гарантировать, что только одно из
сделанных предложений принято. Также, если никаких предложений не поступило,
то ничего не должно быть приняо. Если определённое предложение
(представленное значением) было выбрано, тогда каждый участник
должен иметь возможжность узнать о принятом предложении (его значении).
Из данного описания задачи вытекают следующие требования:

* принято может быть только одно из предложенных значений
* принято может быть только одно значение, и
* процесс не может придти к выводу, что предложение
было принято, если только это дейстительно не произошло в
результате консенсуса.

Не будем пытаться точно обозначить насколько оперативно должен происходить
процесс принятия решения. Однако, целью алгоритма является гарантировать
что одно из предложенных значений в конце концов выбрано, и, когда выбор
сделан, что любой процесс может о нём узнать.

Из описания задачи, любой процесс может выступать в одной из трёх ролей:
proposer, acceptor, learner. В реальности каждый процесс может выступать в
разных ролях относительно разных предложений.

Предположим, что для принятия решений, процессы коммуницируют
друг с другом, посылая друг другу сообщения. Паксос опирается на
асинхронную, но не Византийскую модель пересылки сообщений, то есть:

- процессы работают с произвольной скоростью, могут остановиться или
рестартовать. Т.к. процесс может аварийно завершиться после участия в
принятии решения по одному из предложений, но до того как он о принятом
решении узнал, процесс не сможет узнать о принятом решении если не будет
способа "cохранить" его состояние в отношении этого конкретного решения
на период между завершением и рестартом.

- сообщения могут быть доставлены с произвольной скоростью, могут
дублироватсья и могут быть  не доставлены вообще, но они не могут
быть повреждены.

2.2. Принятие решения.

Одним из самых простых способов принятия решения в поставленных
условиях было бы каким-то образом определиться относительно
одного процесса, который бы всегда выступал в роли акцептора. 
Тогда, любой другой процесс сможет послать своё предложение
акцептору и узнать от него результат - было ли данное предожение принято.
Акцептор, в свою очередь, будет выбирать первое предложение которое
он получит.

К сожалению, хотя это решение и очень простое, оно невозможно на практике,
т.к. в случае выхода из строя акцептора никакие предложения больше
не смогут быть приняты.

Другим способом принятия решения было бы вместо одного акцептора
использовать несколько. Пропозер посылает предложение (значение)
нескольким акцепторам. Каждый из акцепторов может его принять.
Решение считается принятым, когда достаточно большое количество
акцепторов сошлись на одном и том же предложении. Что в данном
контексте означает "достаточно большое"? Для того, чтобы
гарантировать что только одно предложение выбрано из множества,
необходимо обеспечить простое больширство в пользу данного
предложения. Акцептор, в свою очередь, не может "принять" более
чем два предложения (значения), т.к. иначе может быть большинство
по более чем двум предложениям.

По какому же принципу акцептор должен принимать решение? При получении
первого предложения у акцептора нет никакого способа узнать, будут
ли последующие предложения, особенно в среде где сообщение
может потеряться. Также, решение должно быть принято, и желательно
достаточно оперативно, даже если есть только один пропозер.
Таким образом, 

P1 Акцептор обязан принять первое предложение которое он получил.

С этим требованием, однако, есть одна проблема. Несколько значений
могут быть предложены разными пропозерами в примерно одно и то же время, 
и, таким образом, образоваться ситуация, когда каждый акцептор принял
какое-то решение, но каждый своё, и ни одно из предложений не набрало
большинства голосов. Даже если есть только два значения, из которых
предложено выбрать, может случиться так, что примерно половина акцепторов
примет одно, а оставшиеся другое. В этом случае, выход из строя
даже одного акцептора може привести к тому, что понять, какое
решение было принято станет невозможным (т.к. оставшиеся
акцепторы поделятся в своих мнениях поровну - прим. переводчика).

P1, вместе с требованием, что предложение считается принятым только
тогда, когда оно принято большинством акцепторов, побуждает
нас позволить акцепторам принимать более чем одно предложение. 
Различные предложения могут быть идентифицированы акцептором
присвоением им числового идентификтаора, таким образом предложение
должно быть представлено парой <значение, номер предложения>. 
Различные предложения должны получать различные номера.

Как присваивать предложениям различные номера зависит от
реализации, так что на данном этапе давайте предположим что это
возможно.

Таким образом расширив понятие предложения, будем считать
предложение принятым тогда, когда за предложенное значение
проголосовало большинство акцепторов. При этом, т.к. 
различным предложениям присваиваются различные номера, одно и то же
значение может быть использовано в различных предложениях. 

Таким образом, несколько предложений могут быть приняты, но только
тогда, когда они различаются только номером, но предлагают одно и
то же значение.

Чтобы это в конце концов произошло, по индукции по номеру предложения,
достаточно гарантировать: 

P2 Если предложение N значения v принято, тогда любое другое _принятое_
предложение с номером > N должно также предлагать v.

Т.к. идентификаторы предложений возрастают и различны, условие P2
гарантирует что только одно значение выбрано. 
С другой стороны, для того, чтобы быть принятым, предложение должно
быть принято хотя бы одним акцептором. Следовательно, P2 может
быть удовлетворено если:

P2`: Если предложение N со значением v принято, тогда любое
предлоение с номером > N принятое любым акцептором имеет значение v.

P2' не противоречит P1, таким образом какие-то предложения будут приняты.
Т.к. коммуникация между процессами асинхронная, предложение можыт
быть принято даже если какой-то из акцепторов, обозначим его c,  его
вообще не получил.  Представим себе, что новый пропозер
"пробуждается" и делает предложене M, M>N, с другим значением. 
P1 обязывает c принять это предложение, таким образом нарушая P2'. 

Следовательно, для того чтобы P1 и P2' были бы верны, необходимо:

P2'': Если предложенное значение v принято, тогда любое предложение,
с номером M > N, должно иметь значение v. 

Из P2'' следует P2' и P2 т.к. любое принятое предложение должно
быть предложено каким-то пропозером.

Каким же образом пропозер может узнать, какое предложение было принято, 
перед тем как сделать своё предложение?
Для того, чтобы найти ответ на этот вопрос, давайте рассмотрим как
можно доказать, что P2'' выполнено. Для этого необходимо
продемонстрировать что, при условии что некоторое предложение M
значения v принято, любое предложение с номером N > M имеет
значение v. 
Сделаем это по индукции по номеру предложения. То есть, покажем, 
что для любого N > M, все предложения в диапазоне M..N-1
имеют значение v. Давайте для этого рассмотрим как могло было быть принято
предложение M. Для того, чтобы M было принято,  необходимо чтобы
большинство акцепторов (обозначим это множество символом С) приняло его.
Следовательно, по индукции: 

Каждый акцептор в С также принял предложения M..N-1, и каждое предложение
в диапазоне M..N-1 имело значение v.

Т.к. любое множество, состоящее из большинства акцепторов, должно
включать хотя бы одного из участников множества С, для того, чтобы
предложение N имело значение v необходимо соблюсти следующий инвариант:

P2''' Для любого v и N, предложение со значением <N, v> делается только
тогда, когда существует множество S состоящее из большинства
акцепторов, такое что а) ни один акцептор в S не принял предложение
с номером < N или б) v это значение предложения
среди всех предложений с номером мменьше N, принятого акцепторами из S

Иными словаи, P2'' может быть удовлетворено если инварианты из P2'''
соблюдены. Для того, чтобы выполнить требования P2''', пропозеру, 
перед тем как сделать предложение с номером N необходимо узнать
о последнем предложении с номером < N принятом каким-то
большинством акцепторов.

Узнать о предложениях, которые уже были приняты, достаточно просто.
Предсказать какие предложения будут приняты в будущем сложно. Вместо
того, чтобы пытаться предсказывать будущее, пропозер контролирует его
требуя от акцепторов гарантий, что в будущем не будет принято неправильных
решений. Другими словами, пропозер трубет от акцепторов не принимать 
предложений с номером меньше N. Такой подход ведёт к следующему алгоритму
выдвижения предложений:

1. Пропозер выбирает номер предложения N и посылает запрос каждому
участнику некотрого множества акцепторов, требуя ответить:
  а) Обещанием никогда не принимать предложения с номером меньше N
  б) Информации о последнем известном акцептору предложении,
    с максимальным номером < N

Назовём этот запрос prepare запросом с номером N

2. Если пропозер получает ответ на prepare запрос от большинства акцепторов, 
он может послать предложение с номером N и значением v, где v - 
значение выбранное среди значения пропозера и всех значений
которые пропозер получил от акцептров в пункте б). При этом выбирается
значение из предложения с макс. номером N.

Затем пропозер непосредственно делает своё предложения, посылая, 
множеству акцепторов сформированное по описанным выше принципам предложение.
Это должно быть то же множество акцепторов, что и ответило на
первоначальное предложение. Назовём этот тип запроса accept запросом.

Это полностью описывает алгоритм действий пропозера. Что же насчёт
акцептора? Акцептор может получить два вида запросов: prepare и 
accept. Так как любое сообщение всё равно может потеряться, 
акцептор может игнорировать любой запрос, без угрозы
консенсусу. Таким образом, необходимо только решить когда акцептор
должен ответить на запрос. Акцептор может всегда ответить на
prepare запрос. Акцептор может ответить на accept запрос только
тогда, когда нужно принять предложение, то есть только тогда, 
когда акцептор уже на данный момент не обещал в ответе
на какой-либо предыдущий prepare запрос этого не делать.
Иными словами:

P1': Акцептор может принять предложение с номером N тогда
и только тогда когда он не отвечал на prepare запрос с номером
> N.

Можно наблюдать что P1' включает в себя P1.

Теперь мы имеем полный алгоритм выбора значения которое удовлетворило бы
требованиям задачи - в предположении, что мы можем добиться уникальности
номеров предложений. Конечная версия алгоритма может быть получена
в результате применения небольшой оптимизации.

Предположим, акцептор получает prepare запрос с номером N, 
но уже ответил на prepare запрос с номером > N, таким образом
обещая не принимать предлложение с номером N. В этом случае
нет причин для акцептора отвечать на prepare запрос, т.к.
он в любом случае не примет предложение с номером N, которое
хочет сделать пропозер, независимо от значения предложения.
Таким образом, акцептор может свободно проигнорировать такой 
prepare запрос. Он также может проигнорировать prepare запрос
для предложения, которое уже было принято.

В результате этой оптимизации, акцептор обязан помнить только 
последнее предложение которое он когла-либо принял (у него
будет храниться номер последнего известного акцептору принятого
предложения).

Так как P2''' инвариант  обязан сохраняеться даже в случае аварий и
рестарта акцептора, эта информация должна переживать аварии
и рестарт. 
С другой стороны, пропозер всегда может отказаться
от своего предложения и забыть о нем - главное, никода больше 
не делать предложений с тем же номером (т.е. предварительно не
сделав prepare запрос).

Учитывая действия пропозеров и акцепторов, мы видим что алгоритм оперирует
в двух следующих фазах.

Фаза 1. 
а) Пропозер выбирает предложение с номером N и посылает prepare
запрос большинству акцепторов.
b) Если акцептор получает preapre запрос с номером N 
большим чем номер любого prepare запроса на который акцептор
когда-ллибо отвечал, он отвечает на запрос, обещая никогда не
принимать предложение с номером меньше N и с информацией о 
предложении с макс M < N, которое акцептор принял последним.

Фаза 2. 
а) Если пропозер получает ответ на prepare запрос с номером
N от большинства акцепторов, он посылает accept запрос каждому
из акцепторов, содержащий предложение с номером N и значением v,
выбранным в результате поиска значения среди всех ответов
на prepare запрос по максимальному номеру предложения, или
со значением, выбранным пропозером, если prepare запрос
не вернул ни одного предложения. 

б) Акцептор получает акцепт запрос для предложения с номером N
и принимает предложение если только акцептор уже не ответил
на prepare запрос с номером больше N

Пропозер может сделать несколько предложений, если только 
для каждого из них он следует этому алгоритму. Пропозер может
также отаказаться от предложения в любой момент.
(Корректность гарантируется, даже если запросы или ответы
на предложения поступают пропозеру уже после того, как
предложение было заброшено).
Возможно, это хорошая идея для пропозера отказываться от
предложения если какой-то другой пропозер сделал предложение
с большим номером. Таким образом, если акцептор игнорирует preapre
или accept запрос т.к. он уже получил prepare или accept запрос с 
большим номером, он, возможно, должен проинформировать об
этом пропозера, который, в этом случае, должен отказаться
от своего предложения. Это повысит эффективность 
аллгоритма но не повлияет на его корректность.

2.3 Получение инормации о принятом решении.

Для того, чтобы понять, что по какому-то решению достигнут консенсус,
лернер должен убедиться что оно было принято большиством акцепторов.
Очевидный алгоритм - каждый акцептор, когда бы он ни получил предложение,
которое он решил принять, пересылает принятое решение всем лернерам.
Это позволяет лернерам узнать о предложении как только предложение
было принято, но также требует от акцептора коммуницировать с
каждым лёрнером, таким образом каждое предложение будет
генерировать количество сообщений, равное произведению количетсва
акцепторов на количетсо лернеров.

Предположение об отсутсвии Византийских ошибок в среде передачи
сообщений позволяет одному лернеру доверять информации, полученной
от другого лернера. Иными словами, лернер может узнать от другого
лернера что определённое предложение было принято. 
Акцепторы могут информировать о своих решениях избранного лёрнера, который,
в свою очередь, проинформирует всех остальных как только определит,
что консенсус был достигнут. Этот подход требует дополнительного 
тура обмена сообщений, и, следовательно, задержки,
для всех лёрнеров, для того чтобы узнать
о принятом решении.
Это также менее надёжно, т.к. избранный лернер может аварийно завершиться.
Но это экономит количество сообщений - оно должно быть ранно лишь сумме
количества акцепторов и количества лёрнеров.

В общем случае, акцепторы могут информировать о своих решениях
некоторое множество избранных лернеров. каждый из которых в дальнейшем
проинформировал бы остальных лернеов о принятом решении.
Расширение множества избранных лернеров повышает надёжность системы,
ценой увеличения количества сообщений на принятое решение.

В условиях возможных потерь сообщений, значение может быть принято
но при этом ни один лёрнер об этом никогда не узнает. Лёрнер, таким образом,
должен иметь возможность узнать от акцепторов какие решений они приняли, 
но авария акцептора может и это действие сделать неосуществимым.
Вследствие этого, в случае аварии акцептора нет способа узнать, что
решение принято большинством. В этом случае, лернеры узнают о том,
какое решение было принято только тогда, когда новое решение было принято.
Если лернеру необходимо узнать о принятом решении, он может 
попросить пропозера сделать предложение о принятии этого решения, с
использованием алгоритма описанного выше.

2.4 Прогресс

Просто сконструировать сценарий, в котором есть два пропозера, 
оба делающют предложения с увеличивающимися номерами, и ни одно
из этих предложений не может быть принято. Пропозер P завершает 
фазу 1 предлжожения N1. Другой пропозер Q затем завершает фазу 1 предложения
N2 > N1. Пропозер P переходит в фазу 2 и посылает accept
запросы, но они игнорируются, т.к. акцепторы уже пообещали не принимать
предложения с номером меньше чем N2. Не имея консенсуса, пропозер 
P начинает заново фазу 1 для предложения с номером N3 > N2,
и успевает завершить её, таким образом препятствуя консенсусу по
решению N2. И так далее.

Для того чтобы гарантировать прогресс, избранный пропозер должен быть
исопльзования для того чтобы делать предложения. Если избранный
пропозер может успешно коммуницировать с большинством акцепторов. и
он использует предложение с номером большим чем он когда-либо 
уже использовал, тогда он преуспеет в достижении
консенсуса по новому предложению. В случае, если избранный пропозер
узнает о запросе с более высоким номером, он может отказаться
от предложения и в конце концов выбрать предложение с большим номером.

Если достаточная часть процессов системы (пропозер, акцепторы, сеть)
функциональны, живучесть системы может быть достигнута посредством
выборов избранного пропозера. Знамнитые результаты Фишер, Линча и
Паттерсона подтверждают что надёжный алгоритм избрания пропозера должен 
использовать либо фактор случайности, либо реальное время - например, 
таймауы. В любом случае, безопасность алгоритм (т.е. отсутствие
 неправельных решений) гарантирована даже в случае неуспеха выборов.

 2.5 Реализация.

Паксос предполагает сеть взимодействующих процессов. В алгоритме
консенсуса, каждый процесс играет роль акцептора пропозера или
лёрнера. Алгорим выбирает лидера, который играет роль избранного
пропозера и избранного лернера. Алгоритм консенсуса Паксос - остаётся
именно таким, как описано выыше, при этом запросы и ответы посылаются
в виде обычных сообщений. (Ответы должны быть тагированы соответствующим
номером предложения, чтобы избежать путаницы).
Персистентное хранилище, переживающее аварии необходимо для поддержанияя
информации о том, какое последнее предложение принял акцептор. Акцептор, 
таким образом, обязан записать своё решение в персистентное хранилище
перед отправкой ответа.

Нам осталось лишь описать механизм выбора номера предложения,
чтобы не могло существовать двух предложений с одним и тем же номером.
Например, Разные пропозеры могут выбирать номера предложений из
непересекающихся множеств.
Каждый прпозер в этом случае обязан запомнить в персистентном хранилище
предложение с макс. номером которое он когда-либо делал, и начинает 
фазу 1 всегда с номером предложения большим, чем он когда либо 
использовал.

3 Реализация алгоритма как конечного автомата
---------------------------------------------

Простой способ реализовать расрпеделённую систему - набор клиентов, которые
посылают команды центральному серверу. Сервер должен быть описан
как ДКА, который выполняет команды от клиентов в некотором порядке.
ДКА имеет текущее состояние; шаг работы автомата стостоит в обработке
очередной команды, в результате которой автомат выдаёт ответ
и меняет своё текущее состояние.

Например, клиентами распределённой банковской системы могут быть
клерки и состояние ДКА может состоять из счетов пользователей банка
(и их балансов).

Снятие наличных могло бы быть выполнено через выполнение ДКА команды
которая уменьшает баланс определённого счёта тогда и только тогда
когда баланс больше суммы снятия, и генерирует
старый и новый баланс в качестве вывода автомата.

Реализация, использующая центральный сервер приходит в аварийное
состояние если случается авария центрального сервера. 
Таим образом, для того чтобы обеспечить отказоустойчивость 
системы следует использовать коллекцию серверов, каждый 
из которых представляет собой ДКА. Т.к. детерминированный
конечный автомат детерименированный, все серверы обязаны
продуцировать одинаковые последовательности переходов
состояний при условии одинакового ввода.

Клиент, для которого выполняется команда, может в таком случае
использовать любой сервер.

Для того, чтобы гарантировать что все сервера выполняют одну и
ту же последовательность комманд, мы представляем эту последовательность
как множество отдельных экземпляров Паксос консенсуса.
Значение, которое должны утвердить i-й экземпляр алгоритма 
соответствует i-му состоянию распределённому ДКА. Каждый сервер
выполняет все роли - пропозера, акцептора и лернера, в каждом экземпляре
алгоритма. 

На данный момент предположим что множество серверов участвующих
в принятии решения не изменяется, так что все экземпляры алгоритма
работают с одним множеством пропозеров, лёрнеров, акцепторов.

В случае нормального хода событий, один из серверов избран в качестве
лидера, т.е. действует как избранный пропозер (единственный сервер,
который делает предложения) во всех экземплярах алгоритма.
Клиенты посылают команды лидеру, который принимает решение о порядке
в котором команды выполняются, то есть о порядке принятия решения
по каждому экземпляру алгоритма консенсуса.

Если лидер принимает решение что определённая команда клиента должна
быть выполнена 135й по порядку выполнения, он пытается сделать 
так, чтобы эта команда являлась значением 135го экземпляра алгоритма
консенсуса. Обычно пропозер достигает успеха. В случае же неуспеха,
например из-за выхода из строя какого-либо из участников, или 
из-за того, что какой-то другой сервер пришёл к выводу что он является
лидером собрания, и предлагает другое значение в 135м
экземпляре консеснуса. Паксос, однако, гарантирует что в результате
консенсуса будет выбрано не более одного значения.

Ключом к эффективности данного подходя является тот факт, что в Паксосе
предложенное значение не принято до фазы 2. Вспомним, что
после завершения фазы 1 либо значение предложения определено однозначно,
либо пропозер может избрать то значение, которое считает нужным.

Давайте опишем как Паксос ДКА работает в случае нормальных обстоятельств.
Далее обсудим что может пойти не так. Мы разберём что случается
когда избранный лидер выходит из строя и должен быть избран новый лидер.
Ситуация отсутствия лидера складывается и просто при старте
системы, и является частным случаем ситуации, когда ни одно из
предложений ещё не было сделано.

Новый лидер, будучи лернером во всех предыдущих экземплярах алгоритма,
должен иметь полную информацию о подмножестве команд, которые
были приняты в результате предыдущих выполнений алгоритма.
Предположим, что ему известно что команды 1-134, 138 и 139 были
приняты консенсусом (позднее станет понятно как может появиться
брешь в диапазоне принятых команд). Он затем выполняет первую
фазу для экземпляров 135-137 и для всех экземпляров больше 139.
(Ниже опишем как это осуществляется). Предположим, что исход
голосования таков, что определено значение для экземпляра 135 и 140,
но не определены значения для остальных экземпляров. 
Лидер затем выполняет фазу 2 для экземпляров 135 и 140, таким
образом принимая по ним решение.

Лидер, также как и любой другой сервер который знает всё то же самое, что
знает лидер, может после этого выполнить команды 1-135. Но он
не может выполнить команды 138-140, которые также утверждены, т.к.
судьба команд 136 и 137 неизвестна (по ним нет консенсуса, но и
нет консенсуса что нет консенсуса). Лидер может повторно
присвоить номера 136 и 137 командам от клинетов, которые ещё не были
выставлены на голосование. Вместо этого, лидер закроет брешь в диапазоне
выставив на голосование специальные "пустые" команды, вместо
команд 136 и 137. Он делает это выполняя фазу 2 для экземпляров 136 и 
137 алгоритма консенсуса, воспользовавшись своим правом предложить
значение которое считает нужным.
Как только эти предложения были утверждены консенсусом, команды 138-140
могут быть выполнены.

Команды 1-140 теперь выполнены. Лидер такжы выполнил фазу 1 для всех
команд с номером > 140, и он может предложить любое значение для фазы
2 для этих экземпляров. Он присваивает №141 следующей команде полученной
от клиента, предлагая кворуму утвердить эту команду. Она предлагает
№142 следующей команде он получает от клиента, и так далее.

Лидер может предложить команду 142 до того, как решение по 
команде 141 принято. В этой ситуации может случиться так, что
все сообщения посланные по команде 141 потеряны, а решение
по комнаде 142 принято. В этой ситуации ни один лернер 
может даже не узнать о том, что по команде 141 было какое-то
голосование. Когда лидер не получит ответ по фазе 2 консенсуса
141, он перепошлёт сообщения фазы 1. Если на этот раз сообщения
будут доставлены, решение по 141 будет принято. Но может
произойти и так, что с лидером случится авария, и образуется
брешь в диапазоне команд, по которым принято решение. В общем
случае, лидер может оказаться L команд впереди - т.е., он 
может сделать предложение по командам N + 1 ... N + L
после того, как N команды были утверждены консенсусом. Брешь
в L - 1 команд может возникнуть в таком случае.

Новоизбранный лидер выполняет фазу 1 по бесконечному
количетсу экземпляров алгоритма консенсуса - в сценарии выше, для
экземпляров 135-137 и всех экземпляров свыше 139. Используя то
же самое предложение для количества экземпляров, он может сделать это послав
достаточно короткое сообщение всем остальным серверам. В фазе 1 акцептор 
в таком случае будет отвечать более чем просто ОК только если он
получил сообщение по фазе 2 от какого-то пропозера. (в этом сценрии 
это было так для экземпляров 135 и 140). В таком случае, сервер, 
выступающий в роли акцептора, может ответить на все
экзмепляры одним достаточно кратким сообщением. Таким образом,
не является проблемой то, что фаза 1 для потерянных сообщений 
выполняется бесконечно много раз.

Если исходить из того, что авария с лидермо и перевыборы лидера - редкие
ситуации, эффективная стоимость ывполнения одной команды распределённого
ДКА - то есть достижения консенсуа - стоимость выполнения
толкьо 2й фазы алгоритма. Можно показать что вторая фаза ПАксос
консенсуса имеет минимальную возможную стоимость для любого
алгоритма достижения консенсуса в окружении в котором могут произойти
аварии лидера или сети. Таким образом, Паксос алгоритм в своей
сути оптимален.

Дискуссия о нормальном функционировании системы предполагает наличие
лидера, кроме коротких периодов аварии текущего лидера и избрания нового. 

В аваринйых обстоятельствах, избрание лидера может также завершиться неудачей.
Если ни один из серверов не является лидером, никакие новые
команды не могут быть предложены для голосования. Если несколько
серверов считают себя лидерами, они все могут делать предложения
в одном и том же экземпляре консенсуса, и таким образом ни одно
из значений может быть не выбрано. В любом случае безопасность
системы сохранена - два сервера системы никогда не будут иметь
разногласий о том, какое же значение у iЙ принятой комнады. 

Избрание лидера необходимо лишь для того, чтобы обеспечить прогресс.

Если множество серверов может измениться, необходим способ понять
какие серверы участвуют в каком экземпляре алгоритма консенсуса. Наиболее
простой способ это сделать - через изменения состояния распределённго
ДКА, Текущее множество серверов может быть частью состояния ДКА и
процесс изменения количества  может быть обычной командой среди множества
команд ДКА. Мы можем позволить лидеру оказаться L команд впереди 
разрешив множеству серверов, которые выполняют i+L экземпляров алгоритма
консенсуса быть специфицированными в состоянии ДКА после выполнений
iЙ комнады ДКА. Это простая реализация сколь угодно сложного
алгоритма реконфигурации.

